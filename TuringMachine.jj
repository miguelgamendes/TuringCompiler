options
{
	LOOKAHEAD = 1;
}

PARSER_BEGIN(TuringMachine)
import java.io.*;
// código Java que invoca o parser
public class TuringMachine {
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		TuringMachine parser = new TuringMachine(new FileInputStream(args[0]));
		parser.file();
	}
}
PARSER_END(TuringMachine)

JAVACODE
void error_skipto(int kind, String type) {
  ParseException e = generateParseException();
  System.out.println("OMG you wrote a " + type + " wrong!!! D:");
  Token t;
  do {
    t = getNextToken();
  } while(t.kind != kind);
}

// símbolos que não devem ser considerados na análise
SKIP :
{
" " | "\n" | "\t" | "\r"
}
// definição dos tokens (símbolos terminais)
TOKEN :
{
< INTEGER : (["0" - "9"])+ >
|< DIRECTION : "right" | "left" > 
|< SYMBOL : (["a" - "z"] | ["A" - "Z"] | ["0" - "9"]) >
|< STATE_KEYWORD : "State" >
|< CARD_BEG_KEYWORD : "{" >
|< CARD_END_KEYWORD : "}" >
|< READ_KEYWORD : "read" >
|< WRITE_KEYWORD : "write" >
|< MOVE_KEYWORD : "move" >
|< JUMP_KEYWORD : "jump" >
|< SEMICOLON : ";" >
}

// definição da produção
void read() : {}
{
  <READ_KEYWORD><SYMBOL>
}

void write() :
{
}
{
  <WRITE_KEYWORD><SYMBOL>
}

void state() :
{
}
{
  try {
    (<STATE_KEYWORD>
    <INTEGER>
    <CARD_BEG_KEYWORD>)
  } catch(ParseException e) {
    error_skipto(CARD_BEG_KEYWORD, "card header");
  }
}

void nextstate() :
{
}
{
  <JUMP_KEYWORD><INTEGER><SEMICOLON>
}


void direction() :
{
}
{
  <MOVE_KEYWORD><DIRECTION>
}

void line() :
{
}
{
  try {
    (read()
    write()
    direction()
    nextstate())
  } catch (ParseException e) {
    error_skipto(SEMICOLON, "line");
  }
}

void endstate() :
{
}
{
  try {
    <CARD_END_KEYWORD>
  } catch(ParseException e) {
    error_skipto(CARD_END_KEYWORD, "card ending");
  }
}

void card() :
{
}
{
  try {
    state()
    (line())*
    endstate()
  } catch(ParseException e) {
    error_skipto(EOF, "card");
  }
}

void file() :
{
}
{
  (card())*<EOF>
}