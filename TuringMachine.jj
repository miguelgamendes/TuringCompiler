options
{
	LOOKAHEAD = 1;
}

PARSER_BEGIN(TuringMachine)
import java.io.*;
// código Java que invoca o parser
public class TuringMachine {
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		TuringMachine parser = new TuringMachine(new FileInputStream(args[0]));
    /*
    try { */
		  parser.file(); /*
    } catch (ParseException e) {
      //System.out.println(e);
    }
    */
	}
}
PARSER_END(TuringMachine)
// símbolos que não devem ser considerados na análise
SKIP :
{
" " | "\n" | "\t" | "\r"
}
// definição dos tokens (símbolos terminais)
TOKEN :
{
< INTEGER : (["0" - "9"])+ >
|< DIRECTION : "right" | "left" > 
|< SYMBOL : (["a" - "z"] | ["A" - "Z"] | ["0" - "9"]) >
|< STATE_KEYWORD : "State" >
|< CARD_BEG_KEYWORD : "{" >
|< CARD_END_KEYWORD : "}" >
|< READ_KEYWORD : "read" >
|< WRITE_KEYWORD : "write" >
|< MOVE_KEYWORD : "move" >
|< JUMP_KEYWORD : "jump" >
}
// definição da produção
void read() : {}
{
  <READ_KEYWORD><SYMBOL>
}

void write() :
{
}
{
  <WRITE_KEYWORD><SYMBOL>
}

void state() :
{
}
{
  <STATE_KEYWORD>
  try {
    <INTEGER>
  } catch(ParseException e) {
    System.out.println("ERROR: STATE SHOULD BE INTEGER\nFROM");
  }
  <CARD_BEG_KEYWORD>
}

void nextstate() :
{
}
{
  <JUMP_KEYWORD><INTEGER>
}


void direction() :
{
}
{
  <MOVE_KEYWORD><DIRECTION>
}

void line() :
{
}
{
  read()
  write()
  direction()
  nextstate()
}

void card() :
{
}
{
  try {
    state()
  } catch (ParseException e) {
    System.out.println("ERROR: STATE SYNTAX ERROR\nFROM");
  }
  (line())* <CARD_END_KEYWORD>
}

void file() :
{
}
{
  try {
    (card())*<EOF>
  } catch (ParseException e) {
    System.out.println("ERROR: CARD SYNTAX ERROR");
  }
}