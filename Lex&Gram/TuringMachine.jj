options
{
  LOOKAHEAD = 1;
}

PARSER_BEGIN(TuringMachine)
import java.io.*;
// código Java que invoca o parser
public class TuringMachine {
  public static void main(String args[]) throws ParseException, FileNotFoundException {
    TuringMachine parser = new TuringMachine(new FileInputStream(args[0]));
    parser.file();
  }
}
PARSER_END(TuringMachine)

JAVACODE
void error_skipto(int kind, String type) {
  ParseException e = generateParseException();
  System.out.println("OMG you wrote a " + type + " wrong!!! D:");
  Token t;
  do {
    t = getNextToken();
  } while(t.kind != kind);
}

JAVACODE
void tokenerror_skipto(int kind) {
  System.out.println("---ILLEGAL TOKEN---");
  Token t;
  do {
    t = getNextToken();
  } while(t.kind != kind);
}

// símbolos que não devem ser considerados na análise
SKIP :
{
" " 
| "\n" 
| "\t" 
| "\r"
| "("
| ")"
| "["
| "]"
| < EVERYTHINGELSE : ~["0"-"9" , "a"-"z" , "A" - "Z" , "," , ";" , "{" , "}"] >
}

// definição dos tokens (símbolos terminais)
TOKEN :
{
< INTEGER : (["0" - "9"])+ >
|< DIRECTION : "right" | "left" > 
|< SYMBOL : (["a" - "z"] | ["A" - "Z"] | ["0" - "9"]) >
|< STATE_KEYWORD : "State" >
|< CARD_BEG_KEYWORD : "{" >
|< CARD_END_KEYWORD : "}" >
|< READ_KEYWORD : "read" >
|< WRITE_KEYWORD : "write" >
|< MOVE_KEYWORD : "move" >
|< JUMP_KEYWORD : "jump" >
|< SEMICOLON : ";" >
|< COMMA : "," >
|< NOTANUMBER : ~["0"-"9"]>
}

// definição da produção
void read() : {}
{
  {System.out.println("READ");}
  try {
    (<READ_KEYWORD>
    <SYMBOL>
    <COMMA>)
  } catch(ParseException e) {
    error_skipto(COMMA, "read statement");
  }
}

void write() :
{
}
{
  {System.out.println("WRITE");}
  try {
    (<WRITE_KEYWORD>
    <SYMBOL>
    <COMMA>)
  } catch(ParseException e) {
    error_skipto(COMMA, "write statement");
  }
}

void state() :
{
}
{
  {System.out.println("STATE");}
  try {
    (<STATE_KEYWORD>
    <INTEGER>
    <CARD_BEG_KEYWORD>)
  } catch(TokenMgrError e) {
    tokenerror_skipto(CARD_BEG_KEYWORD);
  } catch(ParseException e) {
    error_skipto(CARD_BEG_KEYWORD, "card header");
  }
}

void nextstate() :
{
}
{
  {System.out.println("JUMP");}
  try {
    (<JUMP_KEYWORD>
    <INTEGER>
    <SEMICOLON>)
  } catch(ParseException e) {
    error_skipto(SEMICOLON, "jump statement");
  }
}


void direction() :
{
}
{
  {System.out.println("MOVE");}
  try {
    (<MOVE_KEYWORD>
    <DIRECTION>
    <COMMA>)
  } catch(ParseException e) {
    error_skipto(COMMA, "move statement");
  }
}

void line() :
{
}
{
  {System.out.println("LINE");}
  //try {
    (read()
    write()
    direction()
    nextstate())*
  /*} catch (ParseException e) {
    {System.out.println("LINE ERROR");}
    error_skipto(SEMICOLON, "line");
  }*/
}

void endstate() :
{
}
{
  {System.out.println("CARDEND");}
  <CARD_END_KEYWORD>
  //|
  //error_skipto(CARD_END_KEYWORD, "card ending")
}

void card() :
{
  int correctCard = 1;
  int wrongCard = 0;
  int correctCardCount = 0;
  int wrongCardCount = 0;
}
{
  {System.out.println("CARD");}
  //try {
    state()
    line()
    endstate()
    //endstate()
    [/*correctCardCount=*/card()]
  /*} catch(ParseException e) {
    error_skipto(CARD_END_KEYWORD, "card");
    return ++wrongCardCount;
  }
  { return wrongCardCount; }*/
}

void file() :
{
  int correctCompile = 0;
  int wrongCompile = 0;
}
{
  /*{System.out.println("\nErrors:");}

  correctCompile =*/ card()

  /*{if(wrongCompile == 0)System.out.println("NONE");}
  {System.out.println();}
  {
    if(wrongCompile != 0)
      System.out.println("Compilation complete.\n\nWrong cards: " + wrongCompile);
    else
      System.out.println("Compilation complete.\n\nAll cards correct.");
  }*/

  {System.out.println("EOF");}
  <EOF>
}